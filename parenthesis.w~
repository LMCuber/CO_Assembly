.equ LPAREN, 40
.equ RPAREN, 41
.equ LBRACKET, 91
.equ RBRACKET, 93
.equ LBRACE, 123
.equ RBRACE, 125

.data
	input_str: .asciz "(((]]]"
	format_chr: .asciz "\nc | %c |\n"
	format_int: .asciz "\ni[[ %ld ]]\n"
	format_result: .asciz "\nResult: %ld\n"
	format_twoint: .asciz "\n[%ld], [%ld]\n"

.text

.global main
main:
	enter $0, $0

	# print the input sequence
	leaq input_str(%rip), %rdi
	call printf

	leaq input_str(%rip), %rdi
	call parenthesis
	call print_result

	# post check
	leaq format_int(%rip), %rdi
	movq $999, %rsi
	call printf

	leave
	ret

# LOCAL REGISTERS FOR PARENTHESIS
# %rdi (param): input string to validate
# %rsi: length of input string
# %rcx: loop counter
# %al: current character of string (iteration variable)
# %r8b: last opening parenthesis (fetched from top of stack)
# %r9: number of opening parenthesi
# %r10: number of closing parenthesi
# %r12: return value (0: success, -1: error)
parenthesis:
	enter $0, $0
	# get length
	call strlen
	movq %rax, %rsi

	movq $0, %rcx
	movb $0, %al
	movq $0, %r8
	movq $0, %r9
	movq $0, %r10
	movq $0, %r11
	movq $0, %r12

# for loop
parenthesis_loop:
	# print get current char
	# leaq format_chr(%rip), %rdi
	# movq (%r13, %r12, 1), %rsi	# calculate value of 
	# call printf
	
	movb (%rcx, %rdi, 1), %al  # al is current char from loop (1 byte)
	
	# check if current character (al) is a closing character
	cmpb $RPAREN, %al  # compare current string with closing bracket s
	je check_paren
	cmpb $RBRACKET, %al
	je check_bracket
	cmpb $RBRACE, %al
	je check_brace

	pushq (%rcx, %rdi, 1)
	inc %r9

continue:
	incq %rcx

	# next loop iteration
	cmp %rsi, %rcx		# if counter is less than max value, repeat
	jl parenthesis_loop

	# do one last check
	jmp check_ratio

check_paren:
	movb (%rsp), %r8b
	cmpb $LPAREN, %r8b
	je pop_and_continue
	jmp error_and_end

check_bracket:
	mov (%rsp), %r8b
	cmpb $LBRACKET, %r8b
	je pop_and_continue
	jmp error_and_end

check_brace:
	mov (%rsp), %r8b
	cmpb $LBRACE, %r8b
	je pop_and_continue
	jmp error_and_end






check_correct_closing:
	# is closing, so get last pushed opening char, and compare if same
	movb (%rsp), %r8b		# r8b is the last stack opener
	cmpb $LBRACKET, %r8b
	je pop_and_continue  # if the opener is lbracket, continue
	
	jmp error_and_end

pop_and_continue:
	add $8, %rsp
	inc %r10
	jmp continue

error_and_end:
	mov $-1, %r12
	jmp loop_end

check_ratio:
	cmpq %r9, %r10
	je loop_end
	jmp error_and_end

loop_end:
	#leaq format_chr(%rip), %rdi
	#mov 16(%rsp), %rsi
	#call printf

	
	leave
	ret

print_result:
	enter $0, $0


	leaq format_twoint(%rip), %rdi
	mov %r9, %rsi
	mov %r10, %rdx
	call printf

	leaq format_result(%rip), %rdi
	mov %r12, %rsi
	call printf

	leave
	ret

