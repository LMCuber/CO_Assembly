.equ LPAREN, 40							# (
.equ RPAREN, 41							# )
.equ LBRACKET, 91						# [
.equ RBRACKET, 93						# ]
.equ LBRACE, 123						# {
.equ RBRACE, 125						# }
.equ LCHEVRON, 60						# <
.equ RCHEVRON, 62						# >

.data
	#input_str: .asciz "(({[][]()()()}))"
	ask_input_text: .asciz "\n\tEnter sequence of parentheses: "
	input_format: .asciz "%s"
	input_str: .space 100

	format_chr: .asciz "\nc | %c |\n"
	format_int: .asciz "\ni[[ %ld ]]\n"
	format_result_valid: .asciz "\033[32m\t\"%s\" is VALID\n\n\033[0m"  # green string
	format_result_invalid: .asciz "\033[31m\t\"%s\" is NOT VALID\n\n\033[0m"  # red string
	format_twoint: .asciz "\n[%ld], [%ld]\n"

.text

.global main
main:
	enter $0, $0						# prologue

	# ask user for input string
	leaq ask_input_text(%rip), %rdi		# pass input text as parameter to printf
	call printf							# call printf
	call flush							# call flush
	leaq input_format(%rip), %rdi		# pass the input format as scanf parameter
	leaq input_str(%rip), %rsi			# pass the input string as second parameter
	call scanf							# call scanf

	# process the string and display whether it's valid or not
	leaq input_str(%rip), %rdi			# pass the input string to the parenthesis algorithm
	call parenthesis					# call the input string validator
	call print_result					# print the result after the algorithm finished

	leave								# epilogue
	ret									# finish program

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# * LOCAL REGISTERS FOR THE PARENTHESIS SUBROUTINES							  *
# * %rdi (param): input string to validate		                              *
# *																			  *
# * %rsi: length of input string											  *
# * %rcx: loop counter														  *
# * %r8b: last opening parenthesis (fetched from top of stack)			      *
# * %r9: number of opening parenthesi										  *
# * %r10: number of closing parenthesi										  *
# *	%r11b: current character of string (iteration variable)																	  *
# * %rax: (return value) (0: success, -1: error)							  *
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
parenthesis:
	enter $0, $0						# prologue				
	# get length
	call strlen							# get length of passed %rdi input string
	movq %rax, %rsi						# save that length in %rs

	# set a bunch of local registers to zero. Explanations are given above.
	movq $0, %rcx						
	movq $0, %r8
	movq $0, %r9
	movq $0, %r10
	movb $0, %r11b
	movq $0, %rax

# for loop
parenthesis_loop:
	movb (%rcx, %rdi, 1), %r11b			# save current character in %r11b 
	
	# check if current character is a closing brace (because only those can make the result invalid)
	cmpb $RPAREN, %r11b					# compare current with left parenthesis
	je check_paren						# jump to left parenthesis check
	cmpb $RBRACKET, %r11b				# else, check same with right bracket.
	je check_bracket					# jump to right bracket check.
	cmpb $RBRACE, %r11b					# etc.
	je check_brace
	cmpb $RCHEVRON, %r11b
	je check_chevron

	# continue to next loop iteration
	pushq (%rcx, %rdi, 1)				# push the current analyzed character to the stack
	inc %r9								# increment the number of opened parenthesi

continue:
	# if (for example) check_paren correctly found closing brace, we jump to continue, so the loop can move on
	incq %rcx							# increment string index counte
	cmp %rsi, %rcx						# compare the loop counter with string length
	jl parenthesis_loop					# if string length is less than string length, repeat (loop)

	# do one last check
	jmp check_ratio						# when final character reached, do one last check

# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
# * B R A C K E T  C H E C K S												  *
# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
check_paren:
	movb (%rsp), %r8b					# set %r8b equal to the last pushed stack item
	cmpb $LPAREN, %r8b					# check if that last item is equal to a left parenthesis
	je pop_and_continue					# if so, then pop it (because it has found its match) and continue with the loop
	jmp error_and_end					# else, the closing parenthesis doesn't match it, so immediately raise error

check_bracket:
	# check_paren but for bracket
	mov (%rsp), %r8b					# same as above
	cmpb $LBRACKET, %r8b
	je pop_and_continue
	jmp error_and_end

check_brace:
	# check_paren but for brace
	mov (%rsp), %r8b
	cmpb $LBRACE, %r8b
	je pop_and_continue
	jmp error_and_end

check_chevron:
	# check_paren but for chevron
	mov (%rsp), %r8b
	cmpb $LCHEVRON, %r8b
	je pop_and_continue
	jmp error_and_end

# pops the last stack item (it found its match) and resumes with the loop
pop_and_continue:
	add $8, %rsp						# increment stack pointer by 8 (effectively popping the last item. No pop since we don't want to save it)		
	inc %r10							# increment the counter for number of closing parenthesi
	jmp continue						# continue with the loop since no problems occured

# when an error occured (the closing parenthesis didn't match the last stack pushed opening parenthesis)
error_and_end:
	mov $-1, %rax						# set the subroutine result value to -1 (error)
	jmp loop_end						# jump out of the algorithm and return the the main subroutine to print result

# when no unmatching closing parentheses found, it's maybe because there are too few closing parenthesi.
# so we also have to check whether the amount of opening is equal to the amount of closing
check_ratio:
	cmpq %r9, %r10						# compare the amount of opened and closed parenthesi
	je loop_end							# if they are equal, finish the loop peacefully
	jmp error_and_end					# if not, we must throw the error

# this subroutine successfully deallocates the stack memory we queried using the "enter" from "parenthesis"
loop_end:
	leave								# epilogue
	ret									# resume execution in main

print_result:
	enter $0, $0						# prologue

	# if-else statement
	cmp $0, %rax
	je valid

	# invalid
	leaq format_result_invalid(%rip), %rdi
	jmp both

	valid:
		leaq format_result_valid(%rip), %rdi
	
	both:
		leaq input_str(%rip), %rsi
		call printf

	leave
	ret

# the simple flush function
flush:
	enter $0, $0						# prologue
	mov $0, %rdi						# pass 0 as first parameter
	call fflush							# call fflush (force write string buffer to terminal)
	leave								# epilogue
	ret									# return to main

